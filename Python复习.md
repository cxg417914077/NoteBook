复习
* [Python基础](#python%E5%9F%BA%E7%A1%80)
  * [基本数据类型（\*小数字整数池）](#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%B0%8F%E6%95%B0%E5%AD%97%E6%95%B4%E6%95%B0%E6%B1%A0)
    * [类型检查type()](#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5type)
    * [数值](#%E6%95%B0%E5%80%BC)
    * [布尔值](#%E5%B8%83%E5%B0%94%E5%80%BC)
    * [空值](#%E7%A9%BA%E5%80%BC)
  * [流程控制语句](#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5)
    * [if](#if)
    * [while](#while)
    * [for](#for---)
    * [结束循环](#%E7%BB%93%E6%9D%9F%E5%BE%AA%E7%8E%AF)
  * [函数（三要素：功能、参数、返回值）](#%E5%87%BD%E6%95%B0%E4%B8%89%E8%A6%81%E7%B4%A0%E5%8A%9F%E8%83%BD%E5%8F%82%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC)
    * [lambda（匿名函数）](#lambda%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0)
    * [\*高阶函数（闭包，生成器）](#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E9%97%AD%E5%8C%85%E7%94%9F%E6%88%90%E5%99%A8)
    * [容器、可迭代对象、迭代器、生成器](#%E5%AE%B9%E5%99%A8%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%94%9F%E6%88%90%E5%99%A8)
  * [序列](#%E5%BA%8F%E5%88%97)
    * [序列的通用操作](#%E5%BA%8F%E5%88%97%E7%9A%84%E9%80%9A%E7%94%A8%E6%93%8D%E4%BD%9C)
    * [列表（方法）](#%E5%88%97%E8%A1%A8%E6%96%B9%E6%B3%95)
    * [sort与sorted的区别](#sort%E4%B8%8Esorted%E7%9A%84%E5%8C%BA%E5%88%AB)
    * [元组](#%E5%85%83%E7%BB%84)
    * [字符串](#%E5%AD%97%E7%AC%A6%E4%B8%B2)
    * [解构赋值（解包）](#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E8%A7%A3%E5%8C%85)
  * [字典](#%E5%AD%97%E5%85%B8)
  * [集合](#%E9%9B%86%E5%90%88)
  * [运算符](#%E8%BF%90%E7%AE%97%E7%AC%A6)
    * [三目（元）运算符](#%E4%B8%89%E7%9B%AE%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6)
    * [算数运算符：](#%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6)
    * [关系运算符：](#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6)
    * [赋值运算符：](#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6)
    * [位运算符：](#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6)
    * [逻辑运算符：](#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6)
    * [成员运算符：](#%E6%88%90%E5%91%98%E8%BF%90%E7%AE%97%E7%AC%A6)
    * [身份运算符：](#%E8%BA%AB%E4%BB%BD%E8%BF%90%E7%AE%97%E7%AC%A6)
  * [面向对象](#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1)
    * [对象三要素](#%E5%AF%B9%E8%B1%A1%E4%B8%89%E8%A6%81%E7%B4%A0)
    * [面向对象三大特征](#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81)
    * [<a href="https://pyzh\.readthedocs\.io/en/latest/python\-magic\-methods\-guide\.html" rel="nofollow">魔法方法</a>](#%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95)
      * [构造方法](#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95)
    * [访问控制](#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6)
    * [实例方法（成员方法）](#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95)
    * [构造方法和实例方法的区别](#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB)
    * [实例方法，类方法与静态方法的区别](#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E7%B1%BB%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB)
    * [私有属性](#%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7)
    * [@property](#property)
    * [封装](#%E5%B0%81%E8%A3%85)
    * [继承](#%E7%BB%A7%E6%89%BF)
    * [多态](#%E5%A4%9A%E6%80%81)
    * [设计模式](#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F)
      * [单例模式](#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F)
      * [工厂模式](#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F)
* [Python高级](#python%E9%AB%98%E7%BA%A7)
  * [文件操作](#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C)
    * [步骤：](#%E6%AD%A5%E9%AA%A4)
    * [对象的序列化](#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96)
  * [异常处理](#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86)
    * [常见的异常：](#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%82%E5%B8%B8)
    * [自定义异常类](#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%B1%BB)
  * [模块、包](#%E6%A8%A1%E5%9D%97%E5%8C%85)
    * [if   \_\_name\_\_ == "\_\_main\_\_":      main()](#if---__name__--__main__------main)
    * [常用的包和第三方常用的包](#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8C%85%E5%92%8C%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8C%85)
    * [限制导包的内容](#%E9%99%90%E5%88%B6%E5%AF%BC%E5%8C%85%E7%9A%84%E5%86%85%E5%AE%B9)
  * [闭包](#%E9%97%AD%E5%8C%85)
  * [装饰器](#%E8%A3%85%E9%A5%B0%E5%99%A8)
  * [容器(container)](#%E5%AE%B9%E5%99%A8container)
  * [可迭代对象](#%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1)
  * [迭代器(iterator)](#%E8%BF%AD%E4%BB%A3%E5%99%A8iterator)
  * [生成器(generator)](#%E7%94%9F%E6%88%90%E5%99%A8generator)
    * [生成器表达式](#%E7%94%9F%E6%88%90%E5%99%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F)
  * [垃圾回收机制(Garbage collection(GC))](#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6garbage-collectiongc)
      * [引用计数](#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0)
      * [标记\-清除](#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4)
      * [分代收集](#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86)
  * [进程（process）](#%E8%BF%9B%E7%A8%8Bprocess)
    * [函数式多进程](#%E5%87%BD%E6%95%B0%E5%BC%8F%E5%A4%9A%E8%BF%9B%E7%A8%8B)
    * [类式多进程](#%E7%B1%BB%E5%BC%8F%E5%A4%9A%E8%BF%9B%E7%A8%8B)
    * [进程间的通信](#%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1)
    * [进程池](#%E8%BF%9B%E7%A8%8B%E6%B1%A0)
  * [线程（Thread）](#%E7%BA%BF%E7%A8%8Bthread)
    * [线程锁](#%E7%BA%BF%E7%A8%8B%E9%94%81)
  * [协程](#%E5%8D%8F%E7%A8%8B)
  * [Python 中的进程与线程的使用场景?](#python-%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF)
  * [线程是并发还是并行，进程是并发还是并行？](#%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%B9%B6%E5%8F%91%E8%BF%98%E6%98%AF%E5%B9%B6%E8%A1%8C%E8%BF%9B%E7%A8%8B%E6%98%AF%E5%B9%B6%E5%8F%91%E8%BF%98%E6%98%AF%E5%B9%B6%E8%A1%8C)
  * [并行（parallel）和并发（concurrency）？](#%E5%B9%B6%E8%A1%8Cparallel%E5%92%8C%E5%B9%B6%E5%8F%91concurrency)
  * [网络编程](#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B)
    * [<a href="https://mp\.weixin\.qq\.com/s/En4z9y9rgcnNsKQdruHG3A" rel="nofollow">TCP协议</a>](#tcp%E5%8D%8F%E8%AE%AE)
    * [UDP协议](#udp%E5%8D%8F%E8%AE%AE)
    * [<strong>TCP与UDP的区别：</strong>](#tcp%E4%B8%8Eudp%E7%9A%84%E5%8C%BA%E5%88%AB)
    * [OSI模型](#osi%E6%A8%A1%E5%9E%8B)
    * [socket](#socket)
  * [正则表达式](#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F)
    * [匹配规则](#%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99)
    * [贪婪与非贪婪](#%E8%B4%AA%E5%A9%AA%E4%B8%8E%E9%9D%9E%E8%B4%AA%E5%A9%AA)
    * [修饰符](#%E4%BF%AE%E9%A5%B0%E7%AC%A6)
    * [转义字符（\\）](#%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6)
    * [compile()](#compile)
    * [match()](#match)
    * [search()](#search)
    * [findall()](#findall)
    * [sub()](#sub)
## `Python`基础

> 动态类型、强类型、解释型语言

动态、静态类型区分：

编译阶段就知道变量类型的是静态类型、运行阶段才知道变量类型的是动态类型

强、弱类型区分：

运行时是否自动转换类型   不允许隐式转换的是强类型、允许隐式转换的是弱类型

解释型、编译型区分：

解释型语言运行时才翻译成机器语言（运行一次翻译一次，效率相对较差），编译型语言运行之前需要先编译成机器语言，然后在运行（只需要编译一次，效率相对较高）

### 基本数据类型（*小数字整数池）

数值、字符串、布尔值、空值（不可变类型）

#### 类型检查`type()`

#### 数值

​	`int`整型

​			小整数池[-5,256)

​	`float`浮点型

#### 布尔值

​	`True`（真） `False`（假）

​	实际为整型	`True`相当于1，`False`相当于0

#### 空值

​	`None`

### 流程控制语句

#### `if`

```python
if 条件表达式:
    语句1
else:
    语句2
```

条件表达式为`True`执行语句1，`False`执行语句2

#### `while`

```python
while 条件表达式：
	代码块
```

条件表达式为`True`执行循环体（代码块），继续进行判断

为`False`结束循环

`while`循环中也可以使用`else`

条件表达式为`False`时，结束循环，执行`else`后的代码块

#### `for   `

```python
for 变量 in 序列：
	代码块
```

`for`的代码块会执行多次，序列中有几个元素就执行几次

​              每次执行都会将列表中的元素赋值给变量

####  结束循环

```python
break	#立即结束离它最近的循环，也会将`while`中的`else`一起结束掉
continue	#用来跳过当次循环，不执行本次循环代码块，直接进入下一次循环
```

### 函数（三要素：功能、参数、返回值）

#### `lambda`（匿名函数）

​	语法：`lambda` 参数: 要执行的语句

​	返回一个函数对象

​	用来定义简单的函数

​	使代码简洁，不会提高程序运行效率，降低可读性

#### *高阶函数（闭包，生成器）

> 函数的参数或返回值也是函数的函数就是高阶函数

闭包

> 如果在一个内部函数里，对在外部作用域（但不是在全局作用域）的变量进行引用，那么内部函数就被认为是闭包（closure）。

```python
def closure():
    x = 5
    def sub():
        return x * x
    return sub
```

`map(function, iterable, ···)`

> function函数作用于可迭代对象的每一个元素，生成结果，并返回一个迭代器   python2中返回一个列表

```python
a = map(lambda x : x**2, [1,2,3,4,5])
print([i for i in a])
==> [1, 4, 9, 16, 25]
```

```python
a = map(lambda x,y : x+y, [1,2,3,4,5], [7,8,9])
print([i for i in a])
==> [8, 10, 12]
```

`reduce(function, sequence)`

> 把一个函数作用在一个序列上，这个函数必须接收两个参数，`reduce`把结果继续和序列的下一个元素做累积计算

```python
from functools import reduce
r = reduce(lambda x,y: x+y, [1,2,3,4,5,6])
print(r)
==> 21
```



`filter(function, iterable) `

> function函数依次作用于每个元素，然后根据返回值是`True`还是`False`决定保留还是丢弃该元素。返回一个迭代器。      python2中返回一个列表

```python
fil = filter(lambda x: x%2==0, [1,2,3,4,5])
print([f for f in fil])
==> [2, 4]
```

#### 容器、可迭代对象、迭代器、生成器

- 容器是一系列元素的集合，`str、list、set、dict、file、sockets`对象都可以看作是容器，容器都可以被迭代（用在for，while等语句中），因此他们被称为可迭代对象。
- 可迭代对象实现了`__iter__`方法，该方法返回一个迭代器对象。
- 迭代器持有一个内部状态的字段，用于记录下次迭代返回值，它实现了`__next__`和`__iter__`方法，迭代器不会一次性把所有元素加载到内存，而是需要的时候才生成返回结果。
- 生成器是一种特殊的迭代器，它的返回值不是通过`return`而是用`yield`。

### 序列

> 序列是一种数据结构，序列这种数据结构可以在内存中存储一组有序的数据
>
> 存储效率比较高，查询效率比较差

常见序列

list（列表），str（字符串），tuple（元组）

列表为可变序列

字符串和元组属于不可变序列

序列间转换

```python
list()     #将其他类型转换为列表
str()     #将其他的类型转换为字符串
tuple()   #将其他的类型转换为元组
```

#### 序列的通用操作

​	索引

​	s[i]

​	根据索引获取序列中的元素，索引从0开始，不能超过序列的最大索引，可以是负数，-1为最后一个

​	切片

```python
s[i:j] 
        s[i:j:k] 
            - 对序列进行切片
            - 参数：
                i 起始索引（包括）
                j 结束索引（不包括）
                k 步长
```
```python
x in s		# 检查一个序列中是否包含指定元素
x not in s	# 检查一个序列中是否不包含某个元素
s + t		# 将两个序列连接为一个新序列，必须为相同类型的序列
s * n		# 将序列重复指定的次数
len(s)		# 获取序列的长度
min(s)		# 获取序列中多个值的最小值
max(s)		# 获取序列中多个值的最大值
s.index(x [,i[, j]])	# 获取指定元素在序列中第一次出现的索引，如果没有x则报错
s.count(x)	# 统计x在s中出现的次数
```

#### 列表（方法）

```python
list.append(x)				# 将x添加到列表的末尾
list.extend(iterable)		# 将可迭代对象的所有项添加到列表中， 无视序列类型
list.insert(i, x)			# 将元素插入到指定位置
list.remove(x)				# 根据元素的值删除元素
list.pop([i])				# 根据索引删除并返回序列中的元素， 如果不传递索引则删除最后一个元素
list.clear()				# 清空列表
list.sort(key=None, reverse = False)		# 对列表排序
list.reverse()				# 反转列表
list.copy()					# 对列表进行浅复制
enumerate(list)				# 用于将一个可遍历对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标
```

#### `sort`与`sorted`的区别

`sorted(iterable, key=None, reverse=False)`

​	`key`用列表元素的某个属性或函数进行作为排序依据

```python
L = [('b',8),('a',1),('c',9),('d',4)]
print(sorted(L, key=lambda x: x[1]))
==> [('a', 1), ('d', 4), ('b', 8), ('c', 9)]
```

1. `sort`为列表的方法，`sorted`为`python`的内建函数
2. `sort`对原列表进行排序，`sorted`排好序之后返回一个新列表

#### 元组

​	使用()来创建元组 

 	`t = (1,)`   如果元组中只有一个元素，也要写1个逗号

​	除了不可变，和列表基本一致

#### 字符串

> 字符串就是一系列字符,在python中可以使用 ' 或 " 括起来的都是字符串

注意事项：

* 不能混合使用 ' 和 "
* 相同引号不能嵌套
* 引号不能跨行使用

使用三重引号，来表示长字符串，可以跨行使用

​	占位符

```python
s = 'hello %s' % 'abc'
```

​	转义字符

​	在Python中使用 \ 作为转义字符，如果一个字符前加上了 \ 则会自动对字符进行转义

```python
\" -> "
\' -> '
\\ -> \
\t -> 制表符
\n -> 换行符
\uxxxx -> Unicode编码
```

​	字符串的方法

```python
s = 'abc'
s.isalpha()			# 检查字符串是否全部由字母组成，是返回true不是返回false

# 检查字符串是否全部由数字组成，是返回true不是返回false
s.isnumeric() 		# 表示数字就行比如 一、①、1 都返回True
s.isdigit() 		# 表示数字的符号 1、①
s.isdecimal() 		# 必须得是十进制的数字 1
				
s.islower()			# 检查字符串是否全部为小写
s.isupper()			# 检查字符串是否全部为大写

s.upper()			# 将一个字符串转换为大写
s.lower()			# 将一个字符串转换为小写
s.title()			# 将单词的首字母转换为大写
s.capitalize()		# 将字符串的首字母大写

s.ljust()			# 用来对一个字符串进行左对齐
s.rjust()			# 用来对一个字符串进行右对齐
s.center()			# 用来对一个字符串进行居中对齐
# 参数：
#   width 字符串的长度，如果原来字符串不够，则会自动向左侧填充空格
#   fillchar 填充的字符
print(s.rjust(10, '-'))
print(s.ljust(10, '-'))
print('欢迎光临'.center(40, '-'))

s.split()
# 用来将一个字符串拆分为一个列表，从左到右
#   参数
#       sep 分隔符，将会根据该分隔符来对字符串进行拆分
#       maxsplit 最大的拆分的数量，默认值-1
s = 'a,b,c,d,e,f'
result = s.split(',')
print(result)

rsplit()			# 从右往左拆分字符串

s.join()			# 将一个列表中的元素连接为一个字符串	字符串将会作为连接符来使用
lst = ['a', 'b', 'c', 'd', 'e']
result = '@-@'.join(lst)
>>>'a@-@b@-@c@-@d@-@e'

s.find()     # 从左往右
s.rfind()    # 从右往左
# 查询字符串中是否包含某个子串
#   参数：
#        sub 要查询的子串
#        start 查询的开始位置
#        end 查询的结束位置
#   返回值
#       返回子串第一次出现的索引
#       如果没有返回 -1

s.index()     # 从左往右
s.rindex()    # 从右往左
# 查询字符串中是否包含某个子串
#   参数：
#        sub 要查询的子串
#        start 查询的开始位置
#        end 查询的结束位置
#   返回值
#       返回子串第一次出现的索引
#       如果没有找到子串，会报错 ValueError: substring not found
s = 'Hello World'
result = s.index('l', 4, 6)

s.rstrip() 		# 后边的空格
s.lstrip() 		# 左侧的空格
s.strip()  		# 前后都去
# 去除字符中的前后空格
#   参数：
#       chars 要去除的字符，默认为None，只会去除空白字符

s.startswith()
s.endswith()		# 检查一个字符串是否已指定的内容开头或结尾

s.replace(old, new[, count])
# 该方法用来替换字符串中的指定子串
#   参数：
#       old 被替换的字符串
#       new 新的字符串
#       count 要替换的数量，默认为None，全都替换
```



#### 解构赋值（解包）

​	通过解构赋值，可以将序列中的元素赋值给对应变量

```python
 a,b,c,d,e = 'hello'
 ==> a='h' b='e' c='l' d='l' e='o'
 a,b,*c = 'hello'
 ==> a='h' b='e' c=['l', 'l', 'o']
```

​	交换两个变量的值

```python
a, b = b, a
```

### 字典

> 映射（mapping）
>
> ​      \- 映射是一种数据结构，在映射中可以存储一组无序的数据，在映射中存储的数据成为item(项)
>
> ​          每一个数据就是一项，每一项中都有两个结构一个称为 key 一个称为value,所以映射也称为键值对结构
>
> ​          value（值） 就是所存储的数据。key（键）key是每一个值的键，就相当于值的名字，
>
> ​              通过这个名字可以快速的找到这个值，键就是不能重复的名字。
>
> ​      \- 在Python中，对映射的实现称为 字典（dict）

语法：

`{key:value,key:value,key:value}`

使用 `{}` 来创建字典

使用` dict()` 函数来创建字典

​	`dict(key=value,key=value,key=value)`

 `zip()`可以将两个序列合并为一个序列（合并为包含双值子序列的序列）

```python
a = ['a','b','c','d','e']
b = [1,2,3,4]
c = zip(a,b)
d = dict(c)
print(d)
==> {'a': 1, 'b': 2, 'c': 3, 'd': 4}
```

```python
key in d 
key not in d 		# 检查字典中是否存在某个key

d[key] = value		# 通过key来修改字典的value	
					# 获取字典中不存在的key 会报出 KeyError
					# 如果访问字典中不存在的key会报错，如果为字典中不存在的key赋值会自动添加

d.get(key[, default]) 
           # get() 
             # 可以根据键来获取字典的值
             # 参数：
                 # key 要获取到键
                 # default 可选参数，指定当键不存在时的返回值，默认None
             # 返回值：
                 # 如果key存在，则获取相应的值，如果key不存在返回None，不会报错
del d[key] 		# 根据key删除字典中键值对		如果删除一个不存在的key 会报错
          
d.clear() 		# 清空字典
          
d.pop(key[, default]) 
#          根据key来删除并返回指定的值
#          参数：
#              key 要删除的键
#              default 键不存在时返回的默认值，如果不指定，键不存在时会报错
d.popitem() 
#          删除并返回字典中任意的键值对 （删除最后一个）
#          如果对空字典调用，会报错 KeyError: 'popitem(): dictionary is empty'
#          返回值，返回一个双值元组，返回的是被删除的键值对
d.setdefault(key[, default]) 
#          获取字典的指定值，如果key不存在则自动添加
#          参数：
#              key 要查看的键，如果键不存在则会将该键添加到字典
#              defult 可选值，默认值为None 如果key不存在，则该值会作为value添加
#          返回值：
#              字典中的value
	d.update([other]) 		# 将一个字典中的键值对添加到当前字典中	如果字典中没有这个key，则自动添加，如果有则替换
	d.keys()		# 获取字典中所有的键
	d.values()		# 获取字典中所有的值
	d.itmes() 		# 获取字典中的所有的键值对
遍历字典
    使用 for-in 遍历字典

```

### 集合

> 集合和列表类似，只不过集合中的元素**不能重复**
>
> 集合中存储的数据都是**无序**的，实际上集合就是单独将字典的key提取了

创建集合

​	使用 {} 创建集合

​	有value时，就是字典，没有value就是集合

​	集合中只能存储不可变对象

集合的使用

```python
	  len(s) 
        获取集合的长度
      x in s 
        检查x是否在集合中存在
      x not in s 
        检查x是否不在集合中存在
      s.add(elem) 
        向集合中添加一个新元素
            如果元素已经存在，则无法添加
      s.update(*others) 
        将其他集合中的元素更新到当前集合中
      s.remove(elem) 
        从集合中移除指定元素，如果元素不存在报KeyError
      s.discard(elem) 
        删除集合中一个已有的元素，如果元素不存在不会报错
      s.pop() 
        删除并返回一个集合中的任意元素，如果集合为空则报错
      s.clear() 
        清空集合
      s.copy() 
		对集合进行浅复制
```

集合的关系

​	父集、子集

​        如果一个集合中的所有元素都被另一个集合所包括，则这个集合就称为另一个集合的子集，

​            另一个集合就是这个集合的父集

​      真父集、真子集

​        父集 不仅包含子集中的所有元素，还有子集所没有的元素，则这个父集就是子集的真父集

​            这个子集就是父集的真子集

​      \>= 用来检查一个集合是否是另一个的父集

​      <= 用来检查一个集合是否是另一个集合的子集

​      \>  用来检查一个集合是否另一个集合的真父集

​      <  用来检查一个集合是否是另一个集合的真子集

​      求两个集合的交集，使用 & 来求交集

​      求两个集合的并集，使用 | 来求并集

​      求两个集合的差集，使用 - 来求差集

​      求两个集合的异或集，使用 ^

### 运算符

算术运算符、关系运算符、赋值运算符、逻辑运算符、位运算符、成员运算符、身份运算符。

#### 三目（元）运算符

```python
 [on true] if [expression] else [on false]
```

结果为true 执行[on true]内的语句 

结果为false执行[on false]内的语句

```python
a,b = 2,3

min= a if a<b else b
```



#### 算数运算符：

| 运算符 | 描述                                            | 实例                                               |
| ------ | ----------------------------------------------- | -------------------------------------------------- |
| +      | 加 - 两个对象相加                               | a + b 输出结果 30                                  |
| -      | 减 - 得到负数或是一个数减去另一个数             | a - b 输出结果 -10                                 |
| *      | 乘 - 两个数相乘或是返回一个被重复若干次的字符串 | a * b 输出结果 200                                 |
| /      | 除 - x除以y                                     | b / a 输出结果 2                                   |
| %      | 取模 - 返回除法的余数                           | b % a 输出结果 0                                   |
| **     | 幂 - 返回x的y次幂                               | a**b 为10的20次方， 输出结果 100000000000000000000 |
| //     | 取整除 - 返回商的整数部分（**向下取整**）       | `>>> 9//2 4 >>> -9//2 -5`                          |

#### 关系运算符：

| 运算符 | 描述                                                         | 实例                                     |
| ------ | ------------------------------------------------------------ | ---------------------------------------- |
| ==     | 等于 - 比较对象是否相等                                      | (a == b) 返回 False。                    |
| !=     | 不等于 - 比较两个对象是否不相等                              | (a != b) 返回 true.                      |
| <>     | 不等于 - 比较两个对象是否不相等                              | (a <> b) 返回 true。这个运算符类似 != 。 |
| >      | 大于 - 返回x是否大于y                                        | (a > b) 返回 False。                     |
| <      | 小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。 | (a < b) 返回 true。                      |
| >=     | 大于等于	- 返回x是否大于等于y。                           | (a >= b) 返回 False。                    |
| <=     | 小于等于 -	返回x是否小于等于y。                           | (a <= b) 返回 true。                     |

#### 赋值运算符：

| 运算符 | 描述             | 实例                                  |
| ------ | ---------------- | ------------------------------------- |
| =      | 简单的赋值运算符 | c = a + b 将 a + b 的运算结果赋值为 c |
| +=     | 加法赋值运算符   | c += a 等效于 c = c + a               |
| -=     | 减法赋值运算符   | c -= a 等效于 c = c - a               |
| *=     | 乘法赋值运算符   | c *= a 等效于 c = c * a               |
| /=     | 除法赋值运算符   | c /= a 等效于 c = c / a               |
| %=     | 取模赋值运算符   | c %= a 等效于 c = c % a               |
| **=    | 幂赋值运算符     | c **= a 等效于 c = c ** a             |
| //=    | 取整除赋值运算符 | c //= a 等效于 c = c // a             |

#### 位运算符：

| 运算符 | 描述                                                         | 实例                                                         |
| ------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| &      | 按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0 | (a & b) 输出结果 12 ，二进制解释： 0000 1100                 |
| \|     | 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。 | (a \| b) 输出结果 61 ，二进制解释： 0011 1101                |
| ^      | 按位异或运算符：当两对应的二进位相异时，结果为1              | (a ^ b) 输出结果 49 ，二进制解释： 0011 0001                 |
| ~      | 按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1 。**~x** 类似于 **-x-1** | (~a ) 输出结果 -61 ，二进制解释： 1100 0011，在一个有符号二进制数的补码形式。 |
| <<     | 左移动运算符：运算数的各二进位全部左移若干位，由 **<<** 右边的数字指定了移动的位数，高位丢弃，低位补0。 | a << 2 输出结果 240 ，二进制解释： 1111 0000                 |
| >>     | 右移动运算符：把">>"左边的运算数的各二进位全部右移若干位，**>>** 右边的数字指定了移动的位数 | a >> 2 输出结果 15 ，二进制解释： 0000 1111                  |

#### 逻辑运算符：

| 运算符 | 逻辑表达式 | 描述                                                         | 实例                    |
| ------ | ---------- | ------------------------------------------------------------ | ----------------------- |
| and    | x and y    | 布尔"与" - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。 | (a and b) 返回 20。     |
| or     | x or y     | 布尔"或"	- 如果 x 是非 0，它返回 x 的值，否则它返回 y 的计算值。 | (a or b) 返回 10。      |
| not    | not x      | 布尔"非" - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 | not(a and b) 返回 False |

#### 成员运算符：

| in     | 如果在指定的序列中找到值返回 True，否则返回 False。     | x 在 y 序列中 , 如果 x 在 y 序列中返回 True。     |
| ------ | ------------------------------------------------------- | ------------------------------------------------- |
| not in | 如果在指定的序列中没有找到值返回 True，否则返回 False。 | x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。 |

#### 身份运算符：

| 运算符 | 描述                                        | 实例                                                         |
| ------ | ------------------------------------------- | ------------------------------------------------------------ |
| is     | is 是判断两个标识符是不是引用自一个对象     | **x is y**, 类似 **id(x) == id(y)** , 如果引用的是同一个对象则返回 True，否则返回 False |
| is not | is not 是判断两个标识符是不是引用自不同对象 | **x is not y** ， 类似 **id(a) != id(b)**。如果引用的不是同一个对象则返回结果 True，否则返回 False。 |

### 面向对象

> Python中一切皆对象

Python中有可变对象和不可变对象之分。可变对象创建后内容可以改变，但是地址不会改变；不可变对象创建之后不能改变，如果改变则会指向一个新的对象。

**不可变（immutable）：int、字符串(string)、float、（数值型number）、元组（tuple)**

**可变（mutable）：字典型(dictionary)、列表型(list)、集合(list)**

#### 对象三要素

id（唯一标识），type（对象的类型），value（对象中存储的数据）

当我们通过一个变量对一个对象进行引用时，

​	比如，a=11 它并不是直接将11这个对象存储到了变量中，实际在变量中存储的是对象的id

#### 面向对象三大特征

封装（确保数据的安全性）、继承（确保可扩展性）、多态（确保灵活性）

#### [魔法方法](https://pyzh.readthedocs.io/en/latest/python-magic-methods-guide.html)

> 经常是两个下划线包围来命名的（比如 `__init__` ， `__lt__` ）

##### 构造方法

`__new__()`、`__init__()`、`__del__()`

`__new__()`

当我们调用 类 来创建对象时，

   在类中它会先调用第一个特殊方法 `__new__()`

​       使用该方法创建一个新的对象，并且将其创建的对象作为返回值返回

​       `__new__()`默认情况下做的事情：

​           1、开辟一块新的内存空间用来存储对象（地址就有了）

​           2、将对象的type设置为当前类

​           3、将新的对象返回

   对象创建完毕，会自动调用实例的`__init__()`用来初始化对象

   对象使用完毕，销毁时，调用`__del__()`

`__new__()`里面调用的`__init__()`和`__del__()`，重写`new`时要`super.__new__()`

`__init__()`

`__init__ `会在对象创建完毕以后立即调用，用来对对象进行初始化

当我们调用类创建对象时，类中的参数会自动传递给`__init__()`

`__del__(self)`

`__new__ `和 `__init__` 是对象的构造器， `__del__` 是对象的销毁器。

#### 访问控制

`__getattr__(self, name)`

只有当试图访问不存在的属性时它才会被调用

#### 实例方法（成员方法）

`self`为实例对象

类里面定义的函数

类名.方法名（函数名）（参数）

#### 构造方法和实例方法的区别

​		   A:格式区别
​                        构造方法和类名相同，并且没有返回类型，也没有返回值。
​                        普通成员方法可以任意起名，必须有返回类型，可以没有返回值。
​                B:作用区别
​                        构造方法用于创建对象，并进行初始化值。
​                        普通成员方法是用于完成特定功能的。
​                C:调用区别
​                        构造方法是在创建对象时被调用的，一个对象建立，只调用一次相应构造函数
​                        普通成员方法是由创建好的对象调用，可以调用多次

```python
class MyClass():

    
    # 直接将属性定义在类中，这种属性称为 类属性
    # 类属性可以通过实例对象和类对象访问，但是只能通过类对象修改
    # 类属性都是用来保存一些公共的数据
    a = 10
    def __init__(self):
    	# 可以直接将属性添加到实例对象中，此时这个属性称为实例属性
    	# 实例属性只能被实例访问和修改，无法被类访问和修改
    	# 一般情况下定义的都是实例属性
    	self.b = 'hel
    # 在类中直接定义的方法，称为实例方法    
    # 实例方法，可以通过实例对象和类对象调用
    #   但是注意：通过类对象调用时，不会自动传递self
    def fn(self):
    	print('我是fn方法~~
    # 在方法前添加classmethod，则该方法自动变成类方法
    #   类方法的第一个参数默认是 cls 表示当前的类对象
    #   并且类方法既可以通过实例对象调用也可以通过类对象调用
    @classmethod    
    def fn2(cls):
    	print('我是fn2方法', cls)

    # 添加staticmethod装饰器的方法是 静态方法
    # 静态方法可以通过类和实例调用，并且没有任何默认参数 
    # 静态方法是和对象无关的方法，一般静态方法都是一些工具方法
    #   觉得没有地方放了，就放到一个类中    
    @staticmethod    
    def fn3():
    	print('我是fn3方法')

```



#### 实例方法，类方法与静态方法的区别

```python
class Kls(object):
    def foo(self, x):
        print('executing foo(%s,%s)' % (self, x))

    @classmethod
    def class_foo(cls,x):
        print('executing class_foo(%s,%s)' % (cls,x))

    @staticmethod
    def static_foo(x):
        print('executing static_foo(%s)' % x)


ik = Kls()

# 实例方法
ik.foo(1)
print(ik.foo)
print('==========================================')

# 类方法
ik.class_foo(1)
Kls.class_foo(1)
print(ik.class_foo)
print('==========================================')

# 静态方法
ik.static_foo(1)
Kls.static_foo('hi')
print(ik.static_foo)
--------------------- 
# 输出
executing foo(<__main__.Kls object at 0x0551E190>,1)
<bound method Kls.foo of <__main__.Kls object at 0x0551E190>>
==========================================
executing class_foo(<class '__main__.Kls'>,1)
executing class_foo(<class '__main__.Kls'>,1)
<bound method type.class_foo of <class '__main__.Kls'>>
==========================================
executing static_foo(1)
executing static_foo(hi)
<function static_foo at 0x055238B0>
```

**实例方法**，调用时会把实例`ik`作为第一个参数传递给`self`参数。因此，调用`ik.foo(1)`时输出了实例`ik`的地址。

**类方法**，调用时会把类`Kls`作为第一个参数传递给`cls`参数。因此，调用`ik.class_foo(1)`时输出了`Kls`类型信息。 
前面提到，可以通过类也可以通过实例来调用类方法，在上述代码中，我们再一次进行了验证。

**静态方法**，调用时并不需要传递类或者实例。其实，静态方法很像我们在类外定义的函数，只不过静态方法可以通过类或者实例来调用而已。

#### 私有属性

在类中，可以使用双下划线开头的属性名，来隐藏属性

属性或方法一旦添加了双下划线，则此时属性或方法就变成隐藏属性或方法

此时它们只能在类内部被访问，无法在外部访问

原理：

​      实际上以__开头的属性，在类内部都会进行自动的改名

​      它是将属性名修改为 _类名__属性名

​      `Person`类中的`__name`属性，就被改为了` _Person__name`

`self.__name = name`

但是在开发中，一般情况下不需要使用__开头，所以一般我们的私有变量都会以_开头

默认约定添加了_的属性是私有属性，不要去直接修改，需要通过getter或setter来操作

#### `@property`

被装饰器`@property`装饰的方法可以用调用实例的属性的方式调用该实例方法

```python
class Person:

    def __init__(self,name,age):
            self._name = name
            self._age = age
    # 如果为getter方法，添加一个property这个装饰器
    #   则在调用方法时，就可以向访问一个属性一样调用getter
    #   注意：
    #   
    #   调用时属性名 要 和方法
    @property
    def name(self):
            return self._name
    # 可以在setter方法前添加 一个 @属性名.setter装饰器来设置方法
    #注意：
    #   使用@属性名.setter装饰器前必须先使用property装饰器
    #   @属性名.setter装饰器与property装饰器装饰的两个函数的函数名必须一致
    @name.setter
    def name(self,name):
            self._name = name
    def get_age(self):
            return self._
        def set_age(self,age):
            self._age = age
    #可以通过 property() 函数来设置get 和 set 方法
    #顺序，第一个是get 第二个是set 
    #要使用set必须先设置get
    age = property(get_age,set_age)
```



#### 封装

封装就是将数据存储到对象中，并且通过一些方式来控制数据的访问方式

确保数据的安全性

封装就是将属性私有化，然后通过getter方法来提供访问属性的权限

​      通过setter方法来提供修改属性的权限

  \- 好处：

​      1、可以单独控制属性的可读和可写

​      2、在修改属性时可以对值进行检查，确保属性值合法

​      3、对于计算属性，可以直接通过方法动态返回，不需要写死      

  \--- **封装的好处就是确保了数据的安全性**

#### 继承

继承可以使得子类具有父类的属性和方法或者重新定义、追加属性和方法等

特殊方法也会被继承

在定义类时，可以在类后的()指定该类的父类，如果省略不写，则默认是object

object是最大的父类

\- 查询属性的流程：

​    当我们从一个对象中获取一个属性时:

​        ① 先去当前对象中寻找，有则使用，没有去类对象中寻找

​        ② 类对象中如果有则使用，没有则去父类中寻找

​        ③ 父类中有则用，没有则去父类的父类中寻找

​        ④ 以此类推

​        ⑤ 直到找到object，如果依然没有，则报错

 

可以在子类中创建父类中没有的方法，来对父类进行扩展

也可以在子类中创建父类中已有的方法，来对父类的方法进行重写（override）

 

重写

子类的`__init__`会重写父类的，所以在子类的`init`中，需要将父类的参数都列出来

子类重写`init`以后，需要在`init`中手动调用父类的`init`

在子类中调用父类的方法:

1.使用super()来获取父类

`super().__init__()`

2.直接通过类对象，调用方法，此时self不会自动传递，所以需要手动传递self

`父类名.__init__(self)`



`isinstance()`

用来检查某个对象是否是某个类的实例

如果是，返回True (如果该类是其父类也会返回True)，否则返回 False

`issubclass()`

检查一个类是否是另一个类的子类

`__bases__ `可以获取到当前类的父类

`print(D.__bases__)`

#### 多态

多态（Polymorphism）按字面的意思就是“多种状态”

多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。

```python
print(1 + 1)

print('abc' + 'bcd')
```

同样是加法运算，1+1的结果为两个数相加得2，字符串相加的结果为拼串

同一操作，不同对象，不同的结果



#### 设计模式

##### 单例模式

> 确保一个类只有一个实例，所有使用该实例的客户端都可以访问同一个对象

```python
class SingLeton:
    instance = None
    def __new__(cls, *args, **kwargs):
        if not cls.instance:
            return instance = object.__new__(cls)
        return cls.instance
```

##### 工厂模式

> 为了使客户端不去手动的创建对象，在这里我们可以为客户端提供一个函数, 一个专门用来创建对象的函数，客户端在创建对象时，只需要调用该函数,而不需要找到对应的类，这个函数 就叫做工厂方法

```python
class RedAlien:
    def __str__(self):
        return '红色外星人'
 
class BigAlien:
    def __str__(self):
        return '大个的外星人'

class FastAlien:
    def __str__(self):
        return '很快的外星人'
    
def create_alien(level):
    if level == 1:
        return RedAlien()
    elif level == 2:
        return BigAlien()
    elif level == 3:
        return FastAlien()
    
al = create_alien(3)
```

## Python高级

### 文件操作

> 通过Python程序来对，磁盘中的文件进行各种操作（读写）,文件操作也称为I/O (Input/Output)

#### 步骤：

​        1、打开文件
​           ` open(路径, 操作方式, encoding='字符集')`

   - 该方法用来打开一个磁盘中的文件，会返回一个文件对象
        通过该对象可以对文件做各种操作

                    - 操作方式：
        r 默认值，只读的，文件不存在报错
        w 可写的，文件不存在会创建，存在则截断
        a 追加，会在文件的后边写入内容，文件不存在则创建
        x 新建文件，文件存在报错，不存在创建
        + 扩展功能
        t 默认值，以纯文本的形式打开文件
        b 以二进制文件的形式来打开一个文件

```python
    2、操作文件
        - 读写的方法：
            read()
                - 读取指定字节（符）的数据
                - 如果不指定则读取所有的数据

            readline()
                - 一行一行的读取数据

            readlines()
                - 将读取到的数据按行保存到一个列表中

            write()
                - 将数据写入到文件中，并返回写入的长度

            tell()
                - 返回光标的位置

            seek()
                - 设置光标的位置

    3、关闭文件
        close()
            - 关闭文件
```
`with` 可以专门用来对文件进行操作

使用`with`以后，不用在手动关闭文件，一旦代码块结束，文件会自动关闭

```python
with open('demo01.txt') as file_obj:
	print(file_obj.read())
```

#### 对象的序列化

序列化
  - 将对象写到磁盘的文件，这个过程称为序列化

反序列化

- 从磁盘文件中将对象加载到内存，这个过程称为反序列化

通过 pickle 模块来完成对象的序列化操作

​	`pickle.dump(obj, file)` 序列化的方法

​		该方法用于将一个对象存储到文件中
​		参数：
​			obj 要写入到文件的对象
​			file 要写入到那个文件中
 	` pickle.load(file)` 反序列化的方法

​		该方法用于从一个文件将对象加载出来
​		参数：
​			file 文件对象

​		返回值：
​			返回加载到的对象

`os `模块

`os.listdir(path='.')`

参数：
      path 指定要查看的目录
          默认值 . 表示当前目录
  该方法用来显示当前目录下的所有文件（夹）
  返回的是一个列表，列表中保存的是一个一个字符串，字符串是文件（夹）的名字

`os.getcwd()
`获取当前所在文件夹

`os.chdir(path)
`改变当前所在目录

`os.mkdir(path)
`创建一个目录

`os.makedirs(path)
`创建路径中所有的目录

`os.rmdir(path)
`删除一个空目录

`os.removedirs(name)
`删除一个路径中所有文件夹

`os.remove(path)
`删除一个文件

`os.rename(src, dst)
`可以对一个文件进行重命名 也可以实现剪切的功能

### 异常处理

异常有别于正常，程序执行过程中一旦出现异常程序会立即终止

可能导致异常出现情况：
	语法错误
	变量没找到
	列表索引超过最大索引
	除0
	...

```python
    try:
        # 有可能出错的代码
        pass
    except Exception as e:
        # 出错以后的处理方式
        # raise 将异常抛到调用处
    else:
        # 没出错时执行的代码
        pass
    finally:
        # 永远都会执行的代码
        pass    
```

#### 常见的异常：
​    `Exception `所有异常的父类
​    `ImportError `
​    `ModuleNotFoundError`
​    `IndexError`
​    `KeyError`
​    `NameError`
​    `StopIteration`
​    `SyntaxError`

#### 自定义异常类

只需要让该类，继承Exception，该类就会成为异常类

````python
class MyError(Exception):
    pass
````

### 模块、包

```python
- 模块思想就是化整为零
- 将一个完成的一个程序分解为一个一个小的模块，通过将小的模块进行组合来搭建一个完整的程序
- 将程序分为一个一个模块以后，可以方便模块之间的复用
- 在Python中，模块实际上就是一个文件（夹）
    - 创建模块
        - 创建一个 python 文件
        - 文件的名字就是模块名（除了主模块）
        - 模块名要求必须符合标识符规范

    - 创建包（package）
        - 创建一个文件夹
        - 这个文件夹的名字就是包名（模块名）
        - 在文件夹下要包含一个 __init__.py 文件
            __init__.py 是默认导入的模块，当我们直接导入包时，实际上就是导入init

- 导入模块
    import 模块名
    import 模块名 as 别名
    from 模块名 import 函数
    from 模块名 import 函数 as 别名
    from 模块名 import * (慎用)
    import 模块1, 模块2, 模块3 
    import 模块1
    import 模块2
    import 模块3
```
#### `if   __name__ == "__main__":      main()`

​	`if __name__ == '__main__'`的意思是：当`.py`文件被直接运行时，`if __name__ == '__main__'`之下的代码块将被运行；当`.py`文件以模块形式被导入时，`if __name__ == '__main__'`之下的代码块不被运行。

#### 常用的包和第三方常用的包

常用标准库

​	`pprint、time、sys、os、random、json、pyMySQL、threading、multiprocessing、queue、copy、datetime`

第三方库

​	`Django、Flask、requests、scrapy、xadmin、selery、re、hashlib、md5、virtualenv、selenium、NumPy、pandas、mysqlclient、Pillow`

#### 限制导包的内容

一个模块如果定义有列表`__all__`，则`from module import *` 语句只能导入`__all__`列表中存在的对象

### 闭包

```python
- 闭包就是能够读取其他函数内部变量的函数。
- 闭包主要目的就是隐藏一些不希望其他函数访问到的数据
- 闭包的构成要件：
    ① 函数嵌套
    ② 内部函数要引用外部函数的变量
    ③ 将内部函数作为返回值

- 基本格式：
    def outer():
        # 定义一些变量
        def inner():
            # 引用外部函数的变量

        return inner
```
### 装饰器

```python
- 装饰器是一种设计模式
- 装饰器模式可以在不修改原来函数的基础上来对函数进行扩展
- 基本的格式：
    def outer(func):
        def inner(*arg,**kwarg):
            # 在函数调用前，编写代码，对函数进行装饰

            result = func(*arg,**kwarg)

            # 在函数调用后，编写代码，对函数进行装饰

            return result
        return inner

- 使用装饰器，直接在原函数上添加 @装饰器    
- 例子：
    @test1
    @test2
    def fn():
        pass
- 可以为一个函数指定多个装饰器，装饰会按照自内向外的顺序生效
def login_decorator(func):
    def inner(request,*args,**kwargs):
        if request.user.is_authenticated():
            return func(request,*args,**kwargs)
        else:
            if request.is_ajax():
                return JsonResponse({'status':'nologin','msg':'ajax登陆'})
            url = request.get_full_path()
            ret = redirect(reverse('users:user_login'))
            ret.set_cookie('url',url)
            return ret
    return inner
```
### 容器(container)

> 容器是一种把多个元素组织在一起的数据结构，容器中的元素可以逐个地迭代获取，可以用`in`, `not in`关键字判断元素是否包含在容器中。

### 可迭代对象

> 可以通过for语句来直接遍历的对象都可以被称为可迭代对象，
>
> 拥有`__iter__`特殊方法的对象就是可迭代对象，该方法返回一个迭代器对象。
>
> 对于可迭代对象，可以使用内建函数`iter()`来获取它的迭代器对象：

### 迭代器(iterator)

> 迭代器对象要求支持迭代器协议的对象，在Python中，支持迭代器协议就是实现对象的`__iter__()`和`__next__()`方法。其中`__iter__()`方法返回迭代器对象本身；`__next__()`方法返回容器的下一个元素，在结尾时引发`StopIteration`异常。

迭代器专门用来遍历数据

`iter()` 这个函数用来获取一个 可迭代对象 的迭代器

通过迭代器读取数据时，需要使用 `next() `，该函数每执行一次，就会通过迭代器读取一个数据

当迭代器中的数据读取完毕以后，如果依然继续读取，则会抛出 `StopIteration `异常，来提示读取完毕

迭代器每次只能读取一个数据，并且迭代器只可以读取一次

迭代器中都含所有一个`__next__`方法，当我们通过next()来读取数据时，实际上就是调用迭代器的`__next__`

一个对象是不是可迭代对象，就看它有没有实现 `__iter__` 特殊方法

`__iter__`方法必须返回一个迭代器

### 生成器(generator)

> 生成器通过生成器函数产生,生成器函数可以通过常规的`def`语句来定义，但是不用`return`返回，而是用`yield`一次返回一个结果，在每个结果之间挂起和继续它们的状态，来自动实现迭代协议。
>
> `yield`是一个语法糖，内部实现支持了迭代器协议，同时`yield`内部是一个状态机，维护着挂起和继续的状态。

包含`yield`关键字的函数，就是一个生成器的函数
生成器函数在调用时，不会立即执行，而是返回一个生成器的对象
函数会在对生成器进行遍历时才会执行，当遍历生成器时，
函数会开始执行，并且会执行到`yield`定义的位置，并将`yield`后的值作为返回值返回
再次遍历生成器时，会接着上次执行的位置继续向下执行，依然执行到`yield`处停止
如果执行函数时没有执行到`yield`，则抛出 `StopIteration`

生成器中有一个`send()`方法，可以用来执行生成器，作用相当于`next()`

该方法可以在执行生成器的同时，向生成器传递`yield`的返回值

#### 生成器表达式

> 生成器表达式是列表推倒式的生成器版本，看起来像列表推导式，但是它返回的是一个生成器对象而不是列表对象。将列表生成式[]换成()就是生成器表达式

### 垃圾回收机制(Garbage collection(GC))

> python会对程序中的垃圾对象进行自动回收
>
> **python采用的是引用计数机制为主，标记-清除和分代收集两种机制为辅的策略**
>
> 所谓的垃圾对象就是没有任何变量或对象对其进行引用的对象

禁用分代收集
`gc.disable()`

##### 引用计数

Python语言默认采用的垃圾收集机制是『引用计数法 Reference Counting』，该算法最早George E. Collins在1960的时候首次提出，50年后的今天，该算法依然被很多编程语言使用，『引用计数法』的原理是：每个对象维护一个`ob_ref`字段，用来记录该对象当前被引用的次数，每当新的引用指向该对象时，它的引用计数`ob_ref`加1，每当该对象的引用失效时计数`ob_ref`减1，一旦对象的引用计数为0，该对象立即被回收，对象占用的内存空间将被释放。它的缺点是需要额外的空间维护引用计数，这个问题是其次的，不过最主要的问题是它不能解决对象的“循环引用”，因此，也有很多语言比如`Java`并没有采用该算法做来垃圾的收集机制。

什么是循环引用？A和B相互引用而再没有外部引用A与B中的任何一个，它们的引用计数虽然都为1，但显然应该被回收，例子：

```python
a = { } #对象A的引用计数为 1
b = { } #对象B的引用计数为 1
a['b'] = b  #B的引用计数增1
b['a'] = a  #A的引用计数增1
del a #A的引用减 1，最后A对象的引用为 1
del b #B的引用减 1, 最后B对象的引用为 1
```

![](https://foofish.net/images/recycle-refrence.jpg)

##### 标记-清除

『标记清除（Mark—Sweep）』算法是一种基于追踪回收（tracing GC）技术实现的垃圾回收算法。它分为两个阶段：第一阶段是标记阶段，GC会把所有的『活动对象』打上标记，第二阶段是把那些没有标记的对象『非活动对象』进行回收。那么GC又是如何判断哪些是活动对象哪些是非活动对象的呢？

对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器。

![](https://foofish.net/images/mark-sweep.svg)

在上图中，我们把小黑圈视为全局变量，也就是把它作为root object，从小黑圈出发，对象1可直达，那么它将被标记，对象2、3可间接到达也会被标记，而4和5不可达，那么1、2、3就是活动对象，4和5是非活动对象会被GC回收。

标记清除算法作为Python的辅助垃圾收集技术主要处理的是一些容器对象，比如list、dict、tuple，instance等，因为对于字符串、数值对象是不可能造成循环引用问题。Python使用一个双向链表将这些容器对象组织起来。不过，这种简单粗暴的标记清除算法也有明显的缺点：清除非活动的对象前它必须顺序扫描整个堆内存，哪怕只剩下小部分活动对象也要扫描所有对象。

##### 分代收集

分代回收是一种以空间换时间的操作方式，Python将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代，Python将内存分为了3“代”，分别为年轻代（第0代）、中年代（第1代）、老年代（第2代），他们对应的是3个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python垃圾收集机制就会被触发，把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到中年代去，依此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。同时，分代回收是建立在标记清除技术基础之上。分代回收同样作为Python的辅助垃圾收集技术处理那些容器对象

```python
回收的流程：
  分代收集，以0代链表为例，它会先从链表中找到一个被变量引用的对象，将该对象作为根(root)对象
      然后找到根对象所引用的所有对象，这些对象升级到1代链表。然后继续回到0代中寻找根对象，以此类推
      直到无法找到根对象为止。然后统一对0代链表中的对象进行引用-1，如果引用变为0，则将其回收
(700, 10, 10)
gc.get_threshold() 获取分代收集的设置信息
  返回一个元组，元组中有三个元素，分别对应三代
      700 当0代链表中超过700个对象时，自动进行分代收集
      10  当0代链表回收10次后，对0代和1代进行收集
      10  当1代链表回收10次后，对所有链表进行收集
 
sys.getrefcount() 获取一个对象的引用计数
  通过该方法查看的引用计数，都会比实际的数量大 1
print(sys.getrefcount(a))
print(sys.getrefcount(b))
```

### 进程（process）

> 一个运行的程序（代码）就是一个进程，没有运行的代码叫程序，进程是系统资源分配的最小单位，进程拥有自己独立的内存空间，所以进程间数据不共享，开销大。

```python
- 进程用来保存程序执行过程中的所有的代码和数据
    - 一个程序要执行，必须先创建进程
    - 进程就像一个工厂的厂房一样，它为我们的程序运行提供了一个基本的环境
    - 一般情况下，一个程序只有一个进程，如果为了提高效率可以通过多进程的形式来实现多任务
    - 进程之间是相互独立，无法互相访问其他进程的变量
    - multiprocessing
        - 这是一个跨平台的多进程的模块
        - 核心类
            Process
                - 通过该类来创建一个进程对象
                - 参数：
                    target 目标函数
                    args   位置参数，元组
                    kwargs 关键字参数，字典

        - 方法：
            start() 开启进程
            run()   运行进程中的代码（不会直接调用）
            join()  子进程在主进程之前执行
```

 #### 函数式多进程

```python
from multiprocessing import Process
import time
import os


def fn(num):
    for i in range(5):
        print(str(num).center(40, '-'), os.getpid())
        time.sleep(num)


if __name__ == '__main__':

    # args 用来指定进程的位置参数 kwargs 指定关键字参数
    p1 = Process(target=fn, args=(1,))

    # daemon 用来设置进程是否是一个守护进程
    #  如果是True，则主进程结束，子进程也会一起结束
    #  False 则不会
    # p1.daemon = True
    # p1.daemon = False

    p2 = Process(target=fn, args=(2,))
    p1.start()
    p2.start()

    # 调用join() 子进程不执行完，主进程不会执行
    p1.join()
    p2.join()

    # 一般情况下，主要的逻辑都编写在子进程中
    #   主进程不编写逻辑，只是负责调用子进程

    print('主进程结束~~~')
```

#### 类式多进程

```python
from multiprocessing import Process
from threading import Thread

class Mypprocess(Process):
    def __init__(self,a):
        super().__init__()
        self.a = a

    def run(self):
        for i in range(5):
            print(self.a, i)


class Mythread(Thread):
    def __init__(self, a):
        super().__init__()
        self.a = a

    def run(self):
        for i in range(5):
            print(self.a, i)

if __name__ == '__main__':
    p1 = Mypprocess('进程1')
    p2 = Mypprocess('进程2')
    # p1 = Mythread('线程1')
    # p2 = Mythread('线程2')
    p1.start()
    p2.start()
    p1.join()
    p1.join()
```

#### 进程间的通信

进程与进程之间的运行是完全独立，在一个进程当中无法访问到其他进程中的变量
即使是全局变量 或者是参数，都会在进程中创建一个副本，就相当于对对象进行了深复制
所以，你在进程了做的任何修改，都不会影响到其他进程

**利用队列进行进程间的通信**

```python
from multiprocessing import Process, Queue
# 队列 （FIFO） 先进先出
#   第一个存储的数据，会第一个被取出
# 栈 （LIFO） 后进先出
#   最后一个存储的数据，会被第一个取出

# 在python中，为我们提供了一个队列对象，通过该对象可以在进程间来共享数据
# Queue 用来创建一个队列的实例
# 创建队列时，可以在类中指定一个队列的大小，此时队列最大只能容纳这些数据
q = Queue(3)

# put()用于向队列中存储数据
q.put('hello')
q.put(123)
q.put('你好')
# q.put(True) 如果队列已满，调用put，会一直等待
# q.put_nowait(456) queue.Full

# get()用于获取队列中的第一个数据
r = q.get()
r = q.get()
r = q.get()
# r = q.get(timeout=3)

# get()获取数据时，如果队列中没有数据，不会报错，而是一直等待
#   它会阻塞程序的执行，直到有数据可以取出
# r = q.get()
# r = q.get_nowait() 该方法获取数据，如果有就获取，没有就报错queue.Empty

print(r)
```

#### 进程池

```python
from multiprocessing import Pool
import os, time, random

def long_time_task(name):
    print('Run task %s (%s)...' % (name, os.getpid()))
    start = time.time()
    time.sleep(random.random() * 3)
    end = time.time()
    print('Task %s runs %0.2f seconds.' % (name, (end - start)))

if __name__=='__main__':
    print('Parent process %s.' % os.getpid())
    # 创建进程池时，可以指定池里进程的数量
    p = Pool(4)
    for i in range(5):
        # apply_async 将需要执行的函数添加到进程池中，进程池会自动分配进程按顺序执行
        p.apply_async(long_time_task, args=(i,))
    print('Waiting for all subprocesses done...')
    p.close()
    p.join()
    print('All subprocesses done.')
    # 在进程池中，我们无法通过multiprocessing.Queue来共享数据
```

对`Pool`对象调用`join()`方法会等待所有子进程执行完毕，调用`join()`之前必须先调用`close()`，调用`close()`之后就不能继续添加新的`Process`了。

### 线程（Thread）

> 线程是CPU调度的最小单位。
>
> 线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属于一个进程的其他的线程共享进程所拥有的全部资源。

线程是CPU中的最小的计算单位

在进程中负责运算的是线程，所以也称进程为线程的容器

线程就相当于厂房中的工人

注意：同一个进程中的线程数据可以共享，所以编写多线程序时一定要注意线程安全问题

多线程也是一种多任务的实现方式

多线程使用 threading 模块来实现，它和 multiprocessing 使用方式基本一致

#### 线程锁

> 有互斥锁、可重入锁、死锁。

通过Lock 可以创建一个表示线程锁的对象

```python
from threading import Lock

l1 = Lock()
# 当我们加锁时，如果锁没有锁，可以正常加锁
l1.acquire() # 加锁
# 如果锁已经锁上了，则会等待锁被释放，才能加锁继续向下执行
l1.release() # 开锁
```

获得锁的线程用完后一定要释放锁，否则那些苦苦等待锁的线程将永远等待下去，成为死线程。所以我们用`try...finally`来确保锁一定会被释放。

### 协程

> 是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。 协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

进程里有线程，线程里有协程。

[多线程、多进程、协程、并行、并发问题的面试解析](https://juejin.im/post/5b7bd540e51d4538a67a80e3)

[进程、线程、协程对比](https://www.jianshu.com/p/0ec911909dff)

[进程、线程、协程](http://python.jobbole.com/85781/)

### Python 中的进程与线程的使用场景?

- 多进程适合在 CPU 密集型操作(cpu 操作指令比较多，如位数多的浮点运算)。
- 多线程适合在 IO 密集型操作(读写数据操作较多的，比如爬虫)。

### 线程是并发还是并行，进程是并发还是并行？

线程是并发，进程是并行； 
进程之间相互独立，是系统分配资源的最小单位，同一个线程中的所有线程共享资源。

### 并行（parallel）和并发（concurrency）？

并行：同一时刻多个任务同时在运行。 
并发：在同一时间间隔内多个任务都在运行，但是并不会在同一时刻同时运行，存在交替执行的情况。

### 网络编程

#### [TCP协议](https://mp.weixin.qq.com/s/En4z9y9rgcnNsKQdruHG3A)

TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。

TCP 是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。

所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如 IP 地址、端口号等。

TCP 可以看成是一种字节流，它会处理 IP 层或以下的层的丢包、重复以及错误问题。

在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在 TCP 头部。

TCP 提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用四次挥手来关闭一个连接。

TCP协议则是建立在`IP`协议之上的。TCP协议负责在两台计算机之间建立可靠连接，保证数据包按顺序到达。TCP协议会通过握手建立连接，然后，对每个`IP`包编号，确保对方按顺序收到，如果包丢掉了，就自动重发。

三次握手四次挥手

![TCP](https://mmbiz.qpic.cn/mmbiz_png/9aPYe0E1fb1nEyBVwlRZPFNSwl3BkeYFian001KXuKUicvYT7Pozrf2g50NrMtS2mPRuNYIWdgsSmplf8ic1KuV6g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

#### UDP协议

#### **TCP与UDP的区别：**

1、基于连接与无连接；

2、对系统资源的要求（TCP较多，UDP少）；

3、UDP程序结构较简单；

4、流模式与数据报模式 ；

5、TCP保证数据正确性，UDP可能丢包；

6、TCP保证数据顺序，UDP不保证。

#### OSI模型

第7层：[应用层](https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E5%B1%82)

应用层（Application Layer）提供为应用软件而设的接口，以设置与另一应用软件之间的通信。例如: HTTP，HTTPS，FTP，TELNET，SSH，SMTP，POP3等。

第6层：[表达层](https://zh.wikipedia.org/wiki/%E8%A1%A8%E9%81%94%E5%B1%82)

表达层（Presentation Layer）把数据转换为能与接收者的系统格式兼容并适合传输的格式。

第5层：[会话层](https://zh.wikipedia.org/wiki/%E4%BC%9A%E8%AF%9D%E5%B1%82)

会话层（Session Layer）负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接。

第4层：[传输层](https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E5%B1%82)

传输层（Transport Layer）把传输表头（TH）加至数据以形成数据包。传输表头包含了所使用的协议等发送信息。例如:传输控制协议（TCP）等。

第3层：[网络层](https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%B1%82)

网络层（Network Layer）决定数据的路径选择和转寄，将网络表头（NH）加至数据包，以形成分组。网络表头包含了网络数据。例如:互联网协议（IP）等。

第2层：[数据链路层](https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82)

数据链路层（Data Link Layer）负责网络寻址、错误侦测和改错。当表头和表尾被加至数据包时，会形成帧。数据链表头（DLH）是包含了物理地址和错误侦测及改错的方法。数据链表尾（DLT）是一串指示数据包末端的字符串。例如以太网、无线局域网（Wi-Fi）和通用分组无线服务（GPRS）等。

分为两个子层：逻辑链路控制（logical link control，LLC）子层和介质访问控制（media access control，MAC）子层。

第1层：[物理层](https://zh.wikipedia.org/wiki/%E7%89%A9%E7%90%86%E5%B1%82)

物理层（Physical Layer）在局部局域网上传送[数据帧](https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%B8%A7)（data frame），它负责管理计算机通信设备和网络媒体之间的互通。包括了针脚、电压、线缆规范、集线器、中继器、网卡、主机适配器等。

#### socket

```python
socket(family=AF_INET, type=SOCK_STREAM)
创建socket时，需要两个参数：
  family 用来指定ip协议的版本
          默认值 socket.AF_INET，表示使用 IPv4 的协议
              socket.AF_INET6 表示 IPv6
  type 用来指定请求的协议
      默认值 socket.SOCK_STREAM 表示使用TCP协议
              socket.SOCK_DGRAM 表示使用UDP协议

为socket绑定ip地址和端口号
bind() 用来将socket和一个IP（端口号）地址绑定
需要 address 作为参数：
  (host, port)
host 主机名（ip地址） 字符串
port 端口号 数字        

recv() 用来接收数据，需要一个整数作为参数，来指定接收数据的最大的大小
# 可以用来向指定地址返送数据
sock.sendto(data.encode('utf-8'), (host, port))
```

TCP协议server

```python
import socket

# 创建一个TCP的服务器
sock = socket.socket()

# 绑定ip地址
sock.bind(('', 1234))

# 设置连接的数量
# 3 表示连接的等待的队列中最大数量
sock.listen(1)

# 创建一个循环，用来接收请求
while True:
    # 运行客户端连接服务器
    # accept() 一旦调用，服务器会等待连接的创建，才会向下执行
    # connection
    conn, addr = sock.accept()

    # 创建一个循环，负责接收数据
    while True:
        # 在服务器中接收数据，必须要使用连接对象
        # recv()接收数据时，如果连接已经端开，它会自动返回一个空数据
        data = conn.recv(1024)

        if not data:
            conn.close()
            break

        print(data.decode('utf-8'))
        # 向客户端返回一个信息
        conn.send('你也好！'.encode('utf-8'))

    # print(addr)
    # 数据接收完毕，断开连接(四次挥手)

```

TCP协议client

```python
import socket
import time

sock = socket.socket()

# 创建两个变量，来存储服务器的地址
ser_host = '127.0.0.1'
ser_port = 1234

# 和服务器建立连接（三次握手）
sock.connect((ser_host, ser_port))

# sock.send(f'你好，服务器！'.encode('utf-8'))

# 向服务器发送数据
for i in range(10):
    sock.send(f'你好，服务器！{i}'.encode('utf-8'))
    data = sock.recv(1024)
    print(data.decode('utf-8'))
    time.sleep(2)

# sock.close()
```

TCP通信基本步骤：

![](http://jbcdn2.b0.upaiyun.com/2017/08/e9fe0c92fbce827c80d976dd417a8a82.png)

[Socket 网络编程](http://python.jobbole.com/88396/?utm_source=blog.jobbole.com&utm_medium=relatedPosts)

### 正则表达式

#### 匹配规则

![](https://github.com/cxg417914077/NoteBook/blob/master/images/%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99.png?raw=true)

#### 贪婪与非贪婪

在贪婪匹配下，.*会匹配尽可能多的字符。

加一个?为非贪婪模式，.*?会匹配尽可能少的字符。

#### 修饰符

![](https://github.com/cxg417914077/NoteBook/blob/master/images/%E4%BF%AE%E9%A5%B0%E7%AC%A6.png?raw=true)

#### 转义字符（\）

#### `compile()`

将正则字符串编译成正则表达式对象，可以传入修饰符，匹配方法中就不需要额外传修饰符了。

```python
import re
pattern = re.compile('.*?', re.S)
```

#### `match()`

`match()`方法会尝试从字符串的起始位置匹配正则表达式，如果匹配，就返回匹配成功的结果；如果不匹配，就返回`None`。

第一个参数传入正则表达式，第二个参数传入要匹配的字符串。	

```python
result = re.match(pattern, string)
```

`result`对象有两个方法：`group()`方法可以输出匹配到的内容，恰好是正则表达式规则所匹配的内容；`span()`方法可以输出匹配的范围，就是匹配到的结果字符串在原字符串中的位置范围。

#### `search()`

它在匹配时会扫描整个字符串，然后返回第一个成功匹配的结果。 

#### `findall()`

该方法会搜索整个字符串，然后返回匹配正则表达式的所有内容。

#### `sub()`

替换功能，将匹配到的所有符合的内容修改为指定内容

第一个参数为正则表达式，第二个参数为要替换成的字符串，第三个参数为原字符串