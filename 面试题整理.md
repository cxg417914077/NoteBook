#### 人事问题

公司名字：深圳市明日网络科技有限公司

地址：深圳市宝安区宝安桃花源科技创新园（松岗分园）B座13楼整层

上家公司多少人？具体有哪些部门？你们部门有多少人？都有哪些人员组成？

50多人，研发(19)、财务(2)、人事(5)、产品部(10)，前端1，后端2，UI1，测试1，组长

上家公司附近有什么标志物？ 	平峦山公园、铁岗水库

最大的领导叫什么        	黄宇遂

•1.上家公司税前薪资是多少？ 12000

•2.上家公司税后薪资是多少？	13000 不交五险一金

•3.五险一金缴纳的基数是多少？

•4.有没有五险一金？为什么没有五险一金？	刚去时工资少，离家远，没交

•5.对加班的看法？

•6.自己的职业规划？

7.为什么从上家离职？

#### TCP三次握手和四次挥手

TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。

建立可靠连接，数据完整有序

​	三次握手：

​		1、客户端服务器发送请求报文

​		2、服务器收到请求报文并确认后向客户端发送确认报文

​		3、客户端收到确认报文并确认后也向服务器发送请求报文，服务器收到确认报文之后正式建立连接

​	四次挥手：

​		1、客户端要发送的数据发送完之后客户端向服务器发送释放报文

​		2、服务器收到释放报文后向客户端发送确认报文（进入半关闭状态等待数据传输完成）

​		3、服务器要传输的数据发送完毕之后，服务器想客户端发送释放报文

​		4、客户端收到释放报文后向服务器发送确认报文，断开连接

#### **TCP与UDP的区别：**

1、基于连接与无连接；

2、对系统资源的要求（TCP较多，UDP少）；

3、UDP程序结构较简单；

4、流模式与数据报模式 ；

5、TCP保证数据正确性，UDP可能丢包；

6、TCP保证数据顺序，UDP不保证。

#### Websocket

步骤：

![](http://jbcdn2.b0.upaiyun.com/2017/08/e9fe0c92fbce827c80d976dd417a8a82.png)

#### [HTTP/HTTPS](https://juejin.im/entry/58d7635e5c497d0057fae036)

HTTP:超文本传输协议，浏览器和服务器之间传递信息，以明文方式传输内容，没有数据加密，获取传输报文就可以读取其中的内容，不适合传输敏感信息（最广泛）

HTTPS:安全套接字层超文本传输协议，在HTTP的基础加了入SSL协议，SSL依靠证书来验证服务器身份，并为浏览器和客户端之间的通信加密。作用：建立一个信息安全通道，确认网站的真实性

#### uWSGI

uwsgi与wsgi一样是一种通信协议是uWSGI服务器独有的协议，用于定义传输信息的类型，

uWSGI是一个`web`服务器，实现了`WSGI`协议、`uwsgi`协议、`http`协议等。

#### 分布式celery怎么部署

**Celery****的架构**

Celery的架构由三部分组成，消息中间件（message broker），任务执行单元（worker）和任务执行结果存储（task result store）组成。

部署：

1.在Django项目根目录下创建celery.py文件，对celery进行配置。或者将配置写到一个py文件中，然后导入celery.py文件中。

2.在各个app下建立对应的tasks.py文件，里面是要执行的任务

3.在视图函数中导入任务

4.启动Redis

5.启动worker

**消息中间件**

Celery本身不提供消息服务，但是可以方便的和第三方提供的消息中间件集成，包括，[RabbitMQ](http://rabbitmq.com/),[Redis](http://redis.io/),[MongoDB](http://mongodb.org/)等，这里我先去了解[RabbitMQ](http://rabbitmq.com/),[Redis](http://redis.io/)。

**任务执行单元**

Worker是Celery提供的任务执行的单元，worker并发的运行在分布式的系统节点中

**任务结果存储**

Task result store用来存储Worker执行的任务的结果，Celery支持以不同方式存储任务的结果，包括Redis，MongoDB，Django ORM，AMQP等，这里我先不去看它是如何存储的，就先选用Redis来存储任务执行结果。

#### Django的多线程是怎么实现的

Django本身是单进程的，可以用uwsgi和nginx来实现高并发

#### 每天的访问量，数据库一天存多少数据

#### Redis

#### 1. 什么是Python

- Python是一种解释型语言，在代码运行之前不需要编译。
- Python是一种动态类型语言，在定义变量时不需要声明变量的类型。
- Python代码编写速度快，但是运行速度通常要比编译型语言慢。
- 用途非常广泛——web、运维、数学建模、大数据、机器学习

#### Python常用库

`virtualenv`、`pip`、`PyInstaller` 、`logging `、`pprint`、`time`、`sys`、`os`、`random`、`json`、`pyMySQL`、`threading`、`multiprocessing`、`queue`、`copy`、`datetime`

`Django`、`Flask`、`requests`、`scrapy`、`xadmin`、`selery`、`re`、`hashlib`、`md5`、`selenium`、`NumPy`、`pandas`、`mysqlclient`、`Pillow`

#### 2. 可变对象与不可变对象

- 对象三要素：id（地址、唯一标识）、type（类型）、value（对象中存储的数据）
- 可变对象创建之后value可以改变，但是id不会改变。
- 不可变对象创建之后id、value都不能改变。改变value之后id也会改变，就是一个新的对象。

#### 3. 深拷贝和浅拷贝的区别

- 深拷贝是将对象本身复制给另一个对象。对副本进行修改不会影响原对象。用`deepcopy()`进行深拷贝
- 浅复制是将对象的引用复制给另一个对象。修改副本会影响原对象。

#### 4. 列表和元组区别、联系

- 主要区别就是列表是可变的，元组是不可变的。
- 都是可迭代对象，list、tuple可以互相转换

#### 5. 并行和并发

- 并行：同一时刻多个任务同时在运行。            进程是并行，线程是并发。
- 并发：在同一时间间隔内多个任务都在运行，但是并不会在同一时刻同时运行，存在交替执行的情况。

#### 6. 进程、线程和协程，项目是否用过

- 进程是系统资源分配和调度的最小单位，进程之间是独立的，数据不共享，开销比较大。
- 线程是CPU调度执行的最小单位，线程依赖进程存在，一个进程至少有一个线程，多个线程共享所在进程的资源，提高程序运行效率。
- 协程是一种用户态的轻量级线程，协程的暂停、恢复完全由程序控制，线程的阻塞状态是由操作系统内核来进行切换的，因此，协程的开销远远小于线程的开销。
- 之前写过下载文件时，用过多线程技术，业余时间用过多线程写爬虫，提升效率。

#### 7. 为什么Python下多线程是鸡肋，推荐使用多进程？

- Python的每一个进程里面都有且只有一把全局解释器锁（GIL）。线程执行需要获取GIL，运行代码，释放GIL。多线程时，线程释放锁，然后每个线程去竞争锁，切换线程都会浪费资源。由于GIL锁的存在，Python里一个进程永远只能执行一个线程。所有Python的多线程效率不高。

#### 8. Python中多进程和多线程的使用场景

- 多进程适用于CPU密集型操作
- 多线程适用于IO密集型操作（单线程下有IO操作会进行IO等待，造成不必要的时间浪费，而开启多线程能在线程A等待时，自动切换到线程B，可以不浪费CPU的资源，从而能提升程序执行效率）

#### 9.多线程竞争

- 因为线程之间资源是共享的，所有当各个线程访问共享资源时会出现竞争状态，数据几乎同时被多个线程占用，造成数据混乱，也就是线程不安全。所以需要加锁来解决多线程竞争问题。
- 锁的好处：确保某段代码只能由一个线程执行（某些资源只能被一个线程占用）
- 锁的坏处：阻止多线程并发执行，加锁代码只能以单线程执行，降低效率
- 死锁：若干子线程在系统资源竞争时，都在等待对方对某部分资源解除占用状态，结果是谁也不愿先解锁，互相干等着，程序无法执行下去，这就是死锁
- 锁(Lock)是 Python 提供的对线程控制的对象。有互斥锁、可重入锁、死锁。

#### 10. 实例方法、类方法、静态方法

- 在类里面定义的函数就是方法
- 类方法需要`@classmethod` 修饰并且有个隐藏参数 `cls`
- 静态方法必须有 `@staticmethod`修饰

- 实例方法只能被实例对象调用，静态方法(由`@staticmethod`装饰的方法)、类方法(由`@classmethod`装饰的方法)，可以被类或类的实例对象调用。

#### 11. [内存管理机制及调优手段](https://blog.csdn.net/weixin_40449300/article/details/79521673)

- 内存管理机制：引用计数、垃圾回收、内存池
- 垃圾回收以引用计数为主，标记-清除和分代回收为辅的策略
- 调优手段：
  - 手动垃圾回收（`gc.collect()`）
  - 调高垃圾回收阈（yu）值
  - 避免循环使用（手动解循环引用和使用弱引用）

#### 12.lambda函数、好处

- lambda函数是一个可以接受任意多个参数，返回单个表达式的函数

- lambda函数比较轻便，即扔即用，很适合需要完成一项功能,但是此功能只在此一处使用,连名字都很随意的情况下
- 匿名函数,一般用来给filter, map 这样的函数式编程服务
- 作为回调函数,传递给某些应用,比如消息处理

#### 13.生成器、迭代器、可迭代对象

- 可迭代对象：实现`__iter__()`方法（可以直接用于for循环的对象都可以成为可迭代对象）
- 迭代器：实现了`__iter__()`和`__next__()`方法，迭代器不会一次性把所有的元素加载到内存，而是需要的时候才生成结果，调用一次返回一个结果，最后会抛出`sotpiteration`异常
- 生成器：生成器是一种特殊的迭代器，生成器函数类似于普通的函数，只是在返回结果时把`return`换成了`yield`。